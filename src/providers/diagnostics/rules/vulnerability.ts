import type { OsvSeverityLevel } from '#utils/api/vulnerability'
import type { DiagnosticRule } from '..'
import { getVulnerability, SEVERITY_LEVELS } from '#utils/api/vulnerability'
import { npmxPackageUrl } from '#utils/links'
import { isSupportedProtocol, parseVersion } from '#utils/version'
import { DiagnosticSeverity, Uri } from 'vscode'

const DIAGNOSTIC_MAPPING: Record<Exclude<OsvSeverityLevel, 'unknown'>, DiagnosticSeverity> = {
  critical: DiagnosticSeverity.Error,
  high: DiagnosticSeverity.Warning,
  moderate: DiagnosticSeverity.Information,
  low: DiagnosticSeverity.Hint,
}

export const checkVulnerability: DiagnosticRule = async (dep, pkg) => {
  const parsed = parseVersion(dep.version)
  if (!parsed || !isSupportedProtocol(parsed.protocol))
    return

  const { semver } = parsed
  const versionInfo = pkg.versionsMeta[semver]
  if (!versionInfo)
    return

  const result = await getVulnerability({ name: dep.name, version: semver })
  if (!result)
    return

  const { totalCounts } = result
  const message: string[] = []
  let severity: DiagnosticSeverity | null = null

  for (const s of SEVERITY_LEVELS) {
    const count = totalCounts[s]

    if (count <= 0)
      continue

    if (!severity)
      severity = DIAGNOSTIC_MAPPING[s]

    message.push(`${count} ${s}`)
  }

  if (!message.length)
    return

  return {
    node: dep.versionNode,
    message: `This version has ${message.join(', ')} ${message.length === 1 ? 'vulnerability' : 'vulnerabilities'}`,
    severity: DiagnosticSeverity.Error,
    code: {
      value: 'vulnerability',
      target: Uri.parse(npmxPackageUrl(dep.name, semver)),
    },
  }
}
