import type { OsvSeverityLevel } from '#utils/api/vulnerability'
import type { DiagnosticRule } from '..'
import { getVulnerability, SEVERITY_LEVELS } from '#utils/api/vulnerability'
import { npmxPackageUrl } from '#utils/links'
import { isSupportedProtocol, parseVersion } from '#utils/package'
import { DiagnosticSeverity, Uri } from 'vscode'

const DIAGNOSTIC_MAPPING: Record<Exclude<OsvSeverityLevel, 'unknown'>, DiagnosticSeverity> = {
  critical: DiagnosticSeverity.Error,
  high: DiagnosticSeverity.Warning,
  moderate: DiagnosticSeverity.Information,
  low: DiagnosticSeverity.Hint,
}

// TODO: remove and import once #36 is merged
function comparePrerelease(a: string, b: string): number {
  const pa = a.split('.')
  const pb = b.split('.')
  for (let i = 0; i < Math.max(pa.length, pb.length); i++) {
    if (i >= pa.length)
      return -1
    if (i >= pb.length)
      return 1
    const na = Number(pa[i])
    const nb = Number(pb[i])
    if (!Number.isNaN(na) && !Number.isNaN(nb)) {
      if (na !== nb)
        return na - nb
    } else if (pa[i] !== pb[i]) {
      return pa[i] < pb[i] ? -1 : 1
    }
  }
  return 0
}

// TODO: remove and import once #36 is merged
function lt(a: string, b: string): boolean {
  const [coreA, preA] = a.split('-', 2)
  const [coreB, preB] = b.split('-', 2)
  const partsA = coreA.split('.').map(Number)
  const partsB = coreB.split('.').map(Number)
  for (let i = 0; i < 3; i++) {
    const diff = (partsA[i] || 0) - (partsB[i] || 0)
    if (diff !== 0)
      return diff < 0
  }
  if (preA && !preB)
    return true
  if (!preA || !preB)
    return false
  return comparePrerelease(preA, preB) < 0
}

function getBestFixedInVersion(fixedInVersions: string[]): string | undefined {
  if (!fixedInVersions.length)
    return

  return fixedInVersions.reduce((best, current) => lt(best, current) ? current : best)
}

export const checkVulnerability: DiagnosticRule = async (dep, pkg) => {
  const parsed = parseVersion(dep.version)
  if (!parsed || !isSupportedProtocol(parsed.protocol))
    return

  const { semver } = parsed
  const versionInfo = pkg.versionsMeta[semver]
  if (!versionInfo)
    return

  const result = await getVulnerability({ name: dep.name, version: semver })
  if (!result)
    return

  const { totalCounts, vulnerablePackages } = result
  const message: string[] = []
  let severity: DiagnosticSeverity | null = null

  for (const s of SEVERITY_LEVELS) {
    const count = totalCounts[s]

    if (count <= 0)
      continue

    if (!severity)
      severity = DIAGNOSTIC_MAPPING[s]

    message.push(`${count} ${s}`)
  }

  if (!message.length)
    return

  const rootVulnerabilitiesFixedIn = vulnerablePackages
    .filter((vulnerablePackage) => vulnerablePackage.depth === 'root')
    .flatMap((vulnerablePackage) => vulnerablePackage.vulnerabilities)
    .map((vulnerability) => vulnerability.fixedIn)
    .filter((fixedIn): fixedIn is string => Boolean(fixedIn))
  const fixedInVersion = getBestFixedInVersion(rootVulnerabilitiesFixedIn)
  const messageSuffix = fixedInVersion
    ? ` Upgrade to ${parsed.prefix}${fixedInVersion} to fix.`
    : ''
  const targetVersion = fixedInVersion ?? semver

  return {
    node: dep.versionNode,
    message: `This version has ${message.join(', ')} ${message.length === 1 ? 'vulnerability' : 'vulnerabilities'}.${messageSuffix}`,
    severity: severity ?? DiagnosticSeverity.Error,
    code: {
      value: 'vulnerability',
      target: Uri.parse(npmxPackageUrl(dep.name, targetVersion)),
    },
  }
}
